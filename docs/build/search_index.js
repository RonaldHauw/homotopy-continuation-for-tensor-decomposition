var documenterSearchIndex = {"docs":
[{"location":"#Homotopy-Continuation-For-Tensor-Decomposition-1","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"","category":"section"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"This is a short and rudimentary user guide for Homotopy Continuation For Tensor Decomposition. This package comes with my master's thesis and detailed motivations for the algorithms available in this package can be found in the thesis text.","category":"page"},{"location":"#Getting-Started-1","page":"Homotopy Continuation For Tensor Decomposition","title":"Getting Started","text":"","category":"section"},{"location":"#Installing-the-package-1","page":"Homotopy Continuation For Tensor Decomposition","title":"Installing the package","text":"","category":"section"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"Since this is not an official package, it has to be installed manually.","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"First, load all the dependencies via Julia's package manager.","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"using Pkg\n\nPkg.activate(\"path/to/HomotopyContinuationForTensorDecomposition\")\n\nPkg.instantiate()","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"Secondly, we should install HomotopyContinuationForTensorDecomposition. There are two ways to do this.","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"Add HomotopyContinuationForTensorDecomposition.jl to Julia's LOAD_PATH.","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"push!(LOAD_PATH,\"path/to/src/HomotopyContinuationForTensorDecomposition.jl\")\n\nusing HomotopyContinuationForTensorDecomposition\n","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"Use include().","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"include(\"path/to/src/HomotopyContinuationForTensorDecomposition.jl\")\n\nusing .HomotopyContinuationForTensorDecomposition\n","category":"page"},{"location":"#A-first-example-1","page":"Homotopy Continuation For Tensor Decomposition","title":"A first example","text":"","category":"section"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"The example below shows how to interact with the implemented algorithms.","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"using HomotopyContinuationForTensorDecomposition # hide\nusing LinearAlgebra: norm\n\ndims = (43, 8, 7); # dimensions of the tensor\nr = 5; # tensor rank\n\nX, Y, Z, T = cpd_gen(dims, r); # generate a random tensor\n\nXcalc, Ycalc, Zcalc = cpd(T, dims, r);\n\nTcalc = cpd_gen(Xcalc, Ycalc, Zcalc);\n\nnorm(Tcalc - T)/norm(T) # backward relative error   \n","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"The implemented algorithms only work for third order tensors with dimensions (n₁, n₂, n₃) for which it holds that r < min(n₁, n₂n₃) and n₁ ≧ n₂ ≧ n₃. The implemented methods are:","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"kl_cpd (cpd via the method described by Kuo, Lee [1]);\nkld_fd_cpd (cpd via the dual problem by reducing the size of the square system);\nkld_pr_cpd (cpd via the dual problem by a parameter homotopy);\nkl_lr_cpd (Kuo and Lee's method optimised for low ranks);\ncpd (wrapper which selects the optimal method from those above).","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"[1] Y.-C. Kuo and T.-L. Lee. Computing the unique candecomp/parafac decomposition of unbalanced tensors by homotopie method. Linear Algebra and its applications, 556:238–264, 2018.","category":"page"},{"location":"#Benchmarking-1","page":"Homotopy Continuation For Tensor Decomposition","title":"Benchmarking","text":"","category":"section"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"The file benchmarks/Benchmark.jl contains a small module to test the performance of the different algorithms. Additionally, an interface with Tensorlab2016[2] is provided via the MATLAB package. The following four steps explain how to run some tests.","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"Set Julia's working directory to ../benchmarks.","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"cd(\"path/to/HomotopyContinuationForTensorDecomposition/benchmarks\")","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"Put a copy of Tensorlab2016 in ../benchmarks.\nLoad the Benchmarks module.","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"include(\"Benchmark.jl\")\n\nusing .Benchmarks","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"Call the function run_benchmark().","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"run_benchmark().","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"This starts a command line interface through which it is possible to provide all the experiment settings. Should the options provided there be insufficient, experiments can be created manually and passed as an argument to run_benchmark.","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"\n?Benchmarkinstance # show documentation for the benchmarkinstance\n\n# every experiment is represented by a Benchmarkinstance\nbmis = Benchmarkinstance[]\n\ndims = (43, 8, 7);\nr = 15;\nmodel = 1;\ns = 2.0;\nc = 1.0;\n\npush!(bmis, Benchmarkinstance(dims, r; model=model, s=s, c=c));\n\nrun_benchmark(bmis); # run the experiments in `bmis`\n# ...\n","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"The experiment results will be saved in a .csv file in the folder ../data. Before and after the experiment run_benchmark() prints the exact file name. Additionally, the measurements are printed during the experiment.","category":"page"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"[2] Vervliet N., Debals O., Sorber L., Van Barel M. and De Lathauwer L. Tensorlab 3.0, Available online, Mar. 2016. URL: https://www.tensorlab.net/","category":"page"},{"location":"#CPD-methods-1","page":"Homotopy Continuation For Tensor Decomposition","title":"CPD methods","text":"","category":"section"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"Modules = [HomotopyContinuationForTensorDecomposition, KuoLee, Dual]\nOrder   = [:function, :type]","category":"page"},{"location":"#HomotopyContinuationForTensorDecomposition.cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Tuple{Int64,Int64,Int64},Int64}} where d_type","page":"Homotopy Continuation For Tensor Decomposition","title":"HomotopyContinuationForTensorDecomposition.cpd","text":"cpd(T, dims, r)\n\nChooses and calls the most efficiënt algorithm from\n\nkl_cpd\nkld_fd_cpd\nkld_pr_cpd\nkl_lr_cpd\n\nby taking into acount the dimensions and the rank.\n\nif r < n₂ and r < n₃: kl_lr_cpd\nif r < n₂ or r < n₃: kld_fd_cpd\nif r <= n₂+n₃-2: kld_pr_cpd\nif r < n₁: kl_cpd\n\nIf none of the above conditions are met, cpd throws an assertion error.\n\n\n\n\n\n","category":"method"},{"location":"#KuoLee.kl_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type","page":"Homotopy Continuation For Tensor Decomposition","title":"KuoLee.kl_cpd","text":"kl_cpd\n\nCalculate the cpd of an order 3 tensor via the method described in Kuo, Lee.\n\nY.-C. Kuo and T.-L. Lee. Computing the unique candecomp/parafac decomposition of unbalanced tensors by homotopie method. Linear Algebra and its applications, 556:238–264, 2018.\n\nInputs\n\nT: flattened real or complex tensor, type Array{d_type, 2}\nr: rank of the tensor, type Int64\ndims: tuple of the dimensions, first dimension should be larger than r, type Tuple{Int64, Int64, Int64}.\n\nOutputs\n\nThe method outputs the calculated factor matrices\n\n    T approx (Z_textcalc odot Y_textcalc)X_textcalc^H\n\nXcalc\nYcalc\nZcalc\n\nExample\n\ndims = (43, 8, 7);\nr = 17;\nX, Y, Z, T = cpd_gen(dims, r);\n\nXcalc, Ycalc, Zcalc = kl_cpd(T, r, dims);\n\nT̃ = cpd_gen(Xcalc, Ycalc, Zcalc);\nϵ = norm(T-T̃)/norm(T);\n\n\n\n\n\n","category":"method"},{"location":"#KuoLee.kl_lr_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type","page":"Homotopy Continuation For Tensor Decomposition","title":"KuoLee.kl_lr_cpd","text":"kl_lr_cpd\n\nCalculate the cpd of an order 3 unbalanced flattened tensor via the method described in Kuo, Lee.\n\nY.-C. Kuo and T.-L. Lee. Computing the unique candecomp/parafac decomposition of unbalanced tensors by homotopie method. Linear Algebra and its applications, 556:238–264, 2018.\n\nThis method is optimised towards lower ranks: r < n₂ and r < n₃. The flattened tensor has the following decomposition:\n\n    T = (Z odot Y)X^H = EF^H\n\nAs described in the thesis, this method exploits the information that the linear subspaces 𝐘 and 𝐙 are r dimensional and known. Therefor we search a basis Y for 𝐘 and a basis Z for 𝐙 s.t. Z ⊙ Y is a basis for E.\n\nInputs\n\nT: flattened real or complex tensor, type Array{d_type, 2}\nr: rank of the tensor, type Int64\ndims: tuple of the dimensions, first dimension should be larger than r, type Tuple{Int64, Int64, Int64}.\n\nOutputs\n\nThe method outputs the calculated factor matrices\n\n    T approx (Z_textcalc odot Y_textcalc)X_textcalc^H\n\nXcalc\nYcalc\nZcalc\n\n\n\n\n\n","category":"method"},{"location":"#Dual.kld_fd_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type","page":"Homotopy Continuation For Tensor Decomposition","title":"Dual.kld_fd_cpd","text":"kld_fd_cpd\n\nCalculate the cpd of a flattened order 3 tensor via the dual problem. The algoritm numerically reduces the size of the square system used for homotopy continuation by setting some variables to a random value. This method solves the dual problem by calling dual_solve and than translates the dual problem to the primal via translate_dual_prim. The documentation of these methods elaborates more on the techniques used.\n\nInputs\n\nT: flattened real or complex tensor\nr: rank of the cpd\ndims: tuple of the dimensions, first dimension should be larger than r.\n\nOutputs\n\nThe method outputs the calculated factor matrices\n\n    T approx (Z_textcalc odot Y_textcalc)X_textcalc^H\n\nXcalc\nYcalc\nZcalc\n\nOptional arguments\n\nmaxit_basis: (Int64) maximum number of iterations used in solve_dual.\nmaxit_ortho: (Int64) maximum number of iterations used in translate_dual_prim.\nverbose: (Bool) give some information about the number of iterations / the type of problems solved.\nstrategy: (String) tell solve_dual which methods it should use to grow the basis. See solve_dual for the possible values.\n\nExample\n\ndims = (43, 8, 7);\nr = 6;\nX, Y, Z, T = cpd_gen(dims, r);\n\nXcalc, Ycalc, Zcalc = kld_fd_cpd(T, r, dims);\n\nT̃ = cpd_gen(Xcalc, Ycalc, Zcalc);\nϵ = norm(T-T̃)/norm(T);\n\n\n\n\n\n","category":"method"},{"location":"#Dual.kld_pr_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type","page":"Homotopy Continuation For Tensor Decomposition","title":"Dual.kld_pr_cpd","text":"kld_pr_cpd\n\nCalculate the cpd of an order 3 unbalanced flattened tensor. This method uses a parameter homotopy to solve the dual problem. This function constructs an initial decomposition and then calls kld_pr_cpd_refine.\n\nInputs\n\nT₁: flattened tensor\nr: rank of T₁\ndims: tuple with dimensions (n₁, n₂, n₃) of the tensor  such that   T₁ has dimensions n₂n₃×n₁\n\nOutputs\n\nThe method outputs the calculated factor matrices\n\n    T approx (Z_textcalc odot Y_textcalc)X_textcalc^H\n\nXcalc\nYcalc\nZcalc\n\n\n\n\n\n","category":"method"},{"location":"#Dual.kld_pr_cpd_refine-NTuple{6,Any}","page":"Homotopy Continuation For Tensor Decomposition","title":"Dual.kld_pr_cpd_refine","text":"kld_pr_cpd_refine\n\nCalculate the cpd of an unbalanced flattened order 3 tensor via the dual problem.  The method solves the dual problem by paramter homotopy and requires an initial decomposition.     See kl_pr_cpdfor a wrapper which also constructs the initial decomposition.\n\nInputs\n\nT₀: start flattened tensor\nT₁: target flattened tensor\nY₀: factor matrix of start tensor\nZ₀: factor matrix of start tensor\ndims:  dimensions (n₁, n₂, n₃) of start and target tensor.   Y₀ should have dimensions n₂×r, Z₀ should have dimensions n₃×r.\nr: rank of the tensor\n\nOutputs\n\nThe method outputs the calculated factor matrices\n\n    T approx (Z_textcalc odot Y_textcalc)X_textcalc^H\n\nXcalc\nYcalc\nZcalc\n\n\n\n\n\n","category":"method"},{"location":"#Benchmarks-1","page":"Homotopy Continuation For Tensor Decomposition","title":"Benchmarks","text":"","category":"section"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"Modules = [Benchmarks]\nOrder   = [:function, :type]","category":"page"},{"location":"#Benchmarks.run_benchmark","page":"Homotopy Continuation For Tensor Decomposition","title":"Benchmarks.run_benchmark","text":"run_benchmark\n\nScript which will run experiments. The script prompts for user feedback after printing the settings to the shell. This allows the user to still throw an interrupt exception using ctrl-C.\n\nThe following variables have to be manually inserted in Benchmarks.jl\n\nnb_warmup: number of iterations before we take a measurement.\nnb_samples: number of measurements to take for each experiment (or benchmark_instance).\nbenchmark_set: list of experiments (benchmark_instance) to perform.\nkl: (Bool) indicate if we run kl_cpd. This is mostly the most expensive method.\n\n\n\n\n\n","category":"function"},{"location":"#Benchmarks.Benchmarkinstance","page":"Homotopy Continuation For Tensor Decomposition","title":"Benchmarks.Benchmarkinstance","text":"Benchmarkinstance\n\nStruct which represents an experiment to perform.\n\nContains\n\nn₁: first dimension of tensor.\nn₂: second dimension of tensor.\nn₃: third dimension of tensor.\nr: rank of the tensor.\nη: parameter to controll noise. The noise is applied to the tensor to approximate the empirical condition number.\nmodel: the model used to construct the tensor. The models are described in [3]\ns: parameter used in model 1 and model 2\nc: parameter used in model 1\nsample_fm: can only be false if the tensor format is perfect. In that case a random tensor is generated directly. If true the tensor is generated form random factor matrices.\n\n[3] Breiding and Vannieuwenhoven, A Riemannian trust region method for the canonical tensor rank approximation problem\n\n\n\n\n\n","category":"type"},{"location":"#Helper-functions-1","page":"Homotopy Continuation For Tensor Decomposition","title":"Helper functions","text":"","category":"section"},{"location":"#","page":"Homotopy Continuation For Tensor Decomposition","title":"Homotopy Continuation For Tensor Decomposition","text":"Modules = [DualUtils, KuoLeeUtils, Utils]\nOrder   = [:function, :type]","category":"page"},{"location":"#DualUtils.dual_solve-Union{Tuple{d_type}, Tuple{Array{d_type,2},Tuple{Int64,Int64,Int64},Int64}} where d_type","page":"Homotopy Continuation For Tensor Decomposition","title":"DualUtils.dual_solve","text":"dual_solve\n\nCalculates a rank-one basis for Null(E') by intersecting the positive dimensional variety with hyperplanes. The dimensions of E are n₂n₃ × r. Requires that r < n₂ + n₃ - 2.\n\nAll solutions (𝐮ⱼ, 𝐯ⱼ) satisfy\n\n    (mathbfu_j odot mathbfv_j)^Hmathbfe_i = 0 quad forall i=1dots rquad forall j=1dots n_2n_3-r\n\nThis method is a wrapper for constructing random systems, solving them and afterwards parsing and checking the solutions. Three different solvers are used:\n\nLinpolysolve(): if r < n₂ or r < n₃ it is possible to contruct linear systems in r variables. If this is done depends on the given strategy.\nFull degree solver: calculates all solutions of a nonlinear system using HomotopyContinuation.\ndual_paramsolve: calculates a set of solutions using, then tracks these solutions while the parameters of the system (those which define the hyperplanes) are changed.\n\nUsing the default strategy 'xlastxy' (old naming convention) the method will start by dehomogenizing the system such that it is linear in 𝐯 if r < n₂. When no new independent solutions are found, it will use r variables in 𝐯 and one in 𝐮. In the case that r > n₂, all variables in 𝐯 and r-n₂ variables in 𝐳 are used.\n\nInputs\n\nE basis for the space 𝐄 to which we seek orthogonal rank-one vectors.\ndims dimensions of the tensor.\nr rank of the tensor.\n\nOutputs\n\nsuccess: integer flag which equals 1 if all went well.\nN: the rank-one basis for 𝐍 = Nul(𝐄)\nUV: container with the vectors 𝐮 and 𝐯 such that 𝐮ⱼ ⊙ 𝐯ⱼ = 𝐧ⱼ. The vector 𝐮ⱼ can be accessed as UV[j][2] and the vector 𝐯ⱼ as UV[j][1].\n\nKeyword arguments\n\nverbose: print some info to the command line\nstrategy: indicate a strategy to numerically eliminate variables.\n\nStrategies\n\nThe strategy can be set via the keyword argument strategy. Possible values are\n\n!!! note The strategy names come from an old naming convention.\n\n\"x_last_xy\": if r < n₂ eliminate all variables in 𝐮 such that the dual problem is linear in 𝐯. Once this doesn't result in new solutions or r >= n₂, solve non-linear systems with one variable in 𝐯 and r variables in 𝐮 with the full degree solver.\n\"y_last_yx\": if r < n₃ eliminate all variables in 𝐯 such that the dual problem is linear in 𝐮. Once this doesn't result in new solutions or r >= n₃, solve non-linear systems with one variable in 𝐮 and r variables in 𝐯 with the full degree solver.\n\"optimal\": choose automatically between \"x_last_xy\" and \"y_last_yx\" such that linear systems are used when r < n₂ or r < n₃.\n\"x_last_xypar\": (not properly tested) similar to \"x_last_xy\" but dual_paramsolve is used to solve the nonlinear systems.\n\"y_last_yxpar\": (not properly tested) similar to \"y_last_yx\" but dual_paramsolve is used to solve the nonlinear systems.\n\nPossible improvements:\n\nOptimise memory allocation. Most memory is still allocated 'on the fly'.\nUniform naming conventions in all helper functions.\n\n\n\n\n\n","category":"method"},{"location":"#DualUtils.rankfact_nullspace-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64}} where d_type","page":"Homotopy Continuation For Tensor Decomposition","title":"DualUtils.rankfact_nullspace","text":"rankfact_nullspace\n\nCalculate the full rank factorisation of T s.t. T = EF' and N = null(E').\n\nInputs\n\nT: matrix to factorize\nr: rank of t\n\nOutputs\n\nE: matrix such that T = EF'\nF: matrix such that T = EF'\nN: matrix such that N'E = 0.\n\n\n\n\n\n","category":"method"},{"location":"#DualUtils.translate_dual_prim-NTuple{4,Any}","page":"Homotopy Continuation For Tensor Decomposition","title":"DualUtils.translate_dual_prim","text":"translatedualprim\n\nCalculate a rank-one basis Z ⊙ Y orthogonal to U ⊙ V. The dimensions are\n\nU: n₃ × n₂n₃-r;\nV: n₂ × n₂n₃-r;\nZ: n₃ × r;\nY: n₂ × r.\n\nThis solutions (𝐲ᵢ, 𝐳ᵢ) satisfy\n\n    (mathbfu_j odot mathbfv_j)^H(mathbfz_i odot mathbfy_i) = 0 quad forall i=1dots rquad forall j=1dots n_2n_3-r\n\nMoreover the unless soft is activated the method asserts that the returned solutions are zero-dimensional.\n\nInputs\n\nV: see above.\nU: see above.\ndims: see above.\nr: see above.\n\nKeyword arguments\n\nverbose: (true/false) provide some output on the number of iterations.\nmaxit: (int) maximum number of iterations.\nsigma_threshold: (float) decides when a new vector is considered to be part N. If σ[end]/σ[1] < sigma_threshold the solution is rejected due to linear dependency.\nsoft: (true/false) silences assertions for zero-dimensional solution components. Thus, activating soft will not interrupt the software if a positive dimensional solution component is encountered.\n\nOutputs\n\nsuccess: flag which equals the interger one if the method succeeded.\nYZ: container for 𝐲ᵢ and 𝐳ᵢ which can be accessed as YZ[i][1] and YZ[i][2].\n\nPossible improvements\n\nreduce the number of calls to nullspace.\n\n\n\n\n\n","category":"method"},{"location":"#DualUtils.combis-Tuple{Any,Any,Any}","page":"Homotopy Continuation For Tensor Decomposition","title":"DualUtils.combis","text":"combis\n\nExperimental function to generate some combinatorics. Creates different combinations of select_nb elements out of select_list. The method stops if it can find no new samples or if the number of combinations reaches nb_samples.\n\n\n\n\n\n","category":"method"},{"location":"#DualUtils.dual_constructvars-NTuple{10,Any}","page":"Homotopy Continuation For Tensor Decomposition","title":"DualUtils.dual_constructvars","text":"dual_constructvars\n\nHelper function for the dual_solve() method. The function constructs two arrays of variables 𝐯 and 𝐮     which have a random set of elements set to a random value.\n\n!!! note Internally this method uses a different naming convention.\n\nInputs\n\nn₂: (int) dimension of 𝐯 (corresponding tensor has dimensions n₁×n₂×n₃).\nn₃: (int) dimension of 𝐮.\nr: (int) rank of the corresponding tensor.\nverbose: print some information about the proceedings to stdout.\nsetuv: (string) defines which variables should be set.\nX_combos: (old naming convention, V_combos would be more appropriate) list of different combinations of r numbers from the range 1:n₂.\nY_combos: (old naming convention, U_combos would be more appropriate) list of different combinations of r numbers from the range 1:n₃:\nXcomb_index: (old naming convention) tells the method which 'combo' of X_combos should be used.\nYcomb_index: (old naming convention) similar as above.\nit: global iteration counter. Used to only print a message during the first iteration if verbose equals true.\n\nOutputs\n\nx: (old naming convention, 𝐯 would be more appropriate) array consisting of PolyVar types and / or random values.\ny: (old naming convention, 𝐮 would be more appropriate) similar as above.\nt: if the polynomial system is solved with dual_paramsolve, then t represents the PolyVars in x and y which would otherwise be set to a random value.\nadd_eqs: if there are more than r variables (PolyVar), then add_eqs communicates this further.\nrm_eqs: depreciated\nsetuv: (string) communicates which variables are set.\nvars: array of all variables in the polynomial system (only 'true' variables, so no parameters such as t).\n\n\n\n\n\n","category":"method"},{"location":"#DualUtils.dual_deparsevars-NTuple{13,Any}","page":"Homotopy Continuation For Tensor Decomposition","title":"DualUtils.dual_deparsevars","text":"dual_deparsevars\n\nPut the solutions 𝛇 of the polynomial system at the right place in 𝐮 and 𝐯. Can be interpreted as the inverse function of dual_constructvars.\n\n!!! note Still uses an old naming convention internally.\n\n\n\n\n\n","category":"method"},{"location":"#DualUtils.dual_filtsols-NTuple{8,Any}","page":"Homotopy Continuation For Tensor Decomposition","title":"DualUtils.dual_filtsols","text":"# dual_filtsols\n\nFilter all solutions in 𝐧_list such that\n\ntheir residual is low enough\nthey are not trivial\nif added to the basis N, the vectors are independent enough.\n\n\n\n\n\n","category":"method"},{"location":"#DualUtils.dual_paramsolve-NTuple{9,Any}","page":"Homotopy Continuation For Tensor Decomposition","title":"DualUtils.dual_paramsolve","text":"dual_paramsolve\n\nThe polynomial system is parametrised in t and u. This method first calculates a solution set for a random t0 and u0 after which it tracks those solutions to     random t1 and u1, then it tracks those to t2 and u2 and so on.\n\n\n\n\n\n","category":"method"},{"location":"#DualUtils.dual_solvepolysys-NTuple{13,Any}","page":"Homotopy Continuation For Tensor Decomposition","title":"DualUtils.dual_solvepolysys","text":"dual_solvepolysys\n\nWrapper which based on given settings selects the right solver. It can call four different methods\n\ndual_paramsolve: track a set of solutions to different locations in parameter space.\nHomotopyContinuation.solve(): full degree homotopy.\nHomotopyContinuation.solve(…, variable_groups= …): full degree homotopy with m-homogeneous system.\nlinpolysolve: solves a linear polynomial system.\n\n\n\n\n\n","category":"method"},{"location":"#DualUtils.dual_track_single-Union{Tuple{d_type}, Tuple{Any,Array{d_type,2},Array{d_type,2},Any,Any}} where d_type","page":"Homotopy Continuation For Tensor Decomposition","title":"DualUtils.dual_track_single","text":"# dual_track_single\n\nTrack all solutions of the dual start problem to the target problem:\n\nstart condition: U₀ ⊙ V₀ ⟂ E₀,\ntarget condition: U₁ ⊙ V₁ ⟂ E₁.\n\nInputs\n\nUV₀: container for the start solutions.\nE₀: as explained above.\nE₁: as explained above.\ndims: (n₁, n₂, n₃) dimensions of the tensor. E₀ and E₁ have dimension   n₂n₃×r.\nr: rank of the tensor.\n\nOutputs\n\nsuccess: flag\nUV₁: container for target solutions\n\n\n\n\n\n","category":"method"},{"location":"#DualUtils.linpolysolve-Tuple{Any,Any}","page":"Homotopy Continuation For Tensor Decomposition","title":"DualUtils.linpolysolve","text":"linpolysolve\n\nSolves a system of degree one polynomials.\n\n\n\n\n\n","category":"method"},{"location":"#KuoLeeUtils.constrpoly-Union{Tuple{d_type}, Tuple{Array{d_type,2},Tuple{Int64,Int64,Int64},Int64,Tuple{Array{v_type,1},Array{v_type,1}} where v_type}} where d_type","page":"Homotopy Continuation For Tensor Decomposition","title":"KuoLeeUtils.constrpoly","text":"constrpoly\n\nConstruct the polynomial system for the algorithm kl_cpd.\n\nInputs\n\nN: space to which orthogonal rank-one vectors are sought\ndims: tensor dimensions\nvars: polynomial variables\n\nOutputs\n\n𝐩: array of polynomial equations\n\n\n\n\n\n","category":"method"},{"location":"#KuoLeeUtils.filtsols-Union{Tuple{d_type}, Tuple{Array{Array{d_type,1},1},Array{d_type,2},Tuple{Int64,Int64,Int64},Int64}} where d_type","page":"Homotopy Continuation For Tensor Decomposition","title":"KuoLeeUtils.filtsols","text":"filtsols\n\nFilter solutions which are orthogonal to every vector in N.\n\nInputs\n\n𝛇: array of solution vectors\nN: basis of space to which orthogonal vectors are sought\ndims: dimensions of the tensor\nr: rank of the tensor\n\nOutputs\n\nY_filt: array of vectors 𝐲ᵢ (1≦i≦r) of length r such that residual of (𝐳ᵢ ⊙ 𝐲ᵢ)ᴴ𝐧ⱼ is smallest.\nZ_filt: array of vectors 𝐳ᵢ (1≦i≦r) of length r such that residual of (𝐳ᵢ ⊙ 𝐲ᵢ)ᴴ𝐧ⱼ is smallest.\n\n\n\n\n\n","category":"method"},{"location":"#KuoLeeUtils.normbalance-Tuple{Array{#s17,2} where #s17<:Number,Array{#s18,2} where #s18<:Number,Array{#s19,2} where #s19<:Number}","page":"Homotopy Continuation For Tensor Decomposition","title":"KuoLeeUtils.normbalance","text":"Normbalance\n\nDistribute the norm equally over all factor vectors. Put all angle in X.\n\nInputs\n\nX\nY\nZ\n\nOutputs\n\nX: factor matrix X s.t. ||𝐱ᵢ|| = ||𝐲ᵢ|| = ||𝐳ᵢ|| ∠xᵢ₁ = 0. ∀ i,\nY: factor matrix Y s.t. ||𝐱ᵢ|| = ||𝐲ᵢ|| = ||𝐳ᵢ|| ∠yᵢ₁ = 0. ∀ i,\nZ: factor matrix Z s.t. ||𝐱ᵢ|| = ||𝐲ᵢ|| = ||𝐳ᵢ|| ∀ i\n\n\n\n\n\n","category":"method"},{"location":"#KuoLeeUtils.rankfact-Tuple{Array{#s13,2} where #s13<:Number,Int64}","page":"Homotopy Continuation For Tensor Decomposition","title":"KuoLeeUtils.rankfact","text":"Rankfact\n\nFactorize a matrix in rank one matrices via the singular value decomposition.\n\n    T = EF^T quad E in mathbbF^n_2n_3 times r quad Fin mathbbF^n_1times R\n\n\n    T = U Sigma V^T quad E = U quad F^T = Sigma V^T\n\nInputs\n\nT: two-dimensonal array to be factorized\nr: number of rank one terms\n\nOutput\n\nE: E and F are the factor matrices of the factorization\nF: E anf F are the factor matrices of the factorization\n\n\n\n\n\n","category":"method"},{"location":"#Utils.condtdp-NTuple{5,Any}","page":"Homotopy Continuation For Tensor Decomposition","title":"Utils.condtdp","text":"condtdp\n\nCalculate the condition number of the tensor decomposition problem based on Terracini's matrix.\n\nInputs\n\nX\nY\nZ\ndims\nR\n\n\n\n\n\n","category":"method"},{"location":"#Utils.cpd_gen-Tuple{Tuple{Int64,Int64,Int64},Int64}","page":"Homotopy Continuation For Tensor Decomposition","title":"Utils.cpd_gen","text":"cpd_gen(dims, r)\n\nGenerate a flattened tensor with dimensions n₂n₃×n₁ of rank r. The tensor is generated from random factor matrices as\n\n\n    T = (Z odot Y)X^H\n\n\nInputs\n\ndims: tuple with the dimensions (n₁, n₂, n₃).\nr: the desired tensor rank\n\nOutput\n\nX: factor matrix of dimension n₁×r\nY: factor matrix of dimension n₂×r\nZ: factor matrix of dimension n₃×r\nT: flattened tensor n₂n₃×n₁\n\n\n\n\n\n","category":"method"},{"location":"#Utils.cpd_gen-Union{Tuple{d_type}, Tuple{Array{d_type,2},Array{d_type,2},Array{d_type,2}}} where d_type","page":"Homotopy Continuation For Tensor Decomposition","title":"Utils.cpd_gen","text":"cpd_gen(X, Y, Z)\n\nGenerate a flattened tensor from the given factor matrices such that\n\n\n    T = (Z odot Y)X^H\n\n\n\n\n\n\n","category":"method"},{"location":"#Utils.signnorm-Tuple{Array{#s18,N} where N where #s18<:Number}","page":"Homotopy Continuation For Tensor Decomposition","title":"Utils.signnorm","text":"signnorm\n\nRescale matrix columns such that the first row has positive sign. In the case of complex entries, the elements on the first row have zero complex angle.\n\nExamples\n\n>> A\n>> 2×2 Array{Complex{Float64},2}:\n    1.30736-1.34255im    0.183123-0.504201im\n    -0.00153446+0.0305201im  0.222609-0.0412371im\n>> signnorm(A)\n>> 2×2 Array{Complex{Float64},2}:\n    1.87393+1.5908e-16im  0.536426-2.60882e-17im\n    -0.0229362+0.0201932im   0.114753+0.195159im\n\n\n\n\n\n","category":"method"}]
}
