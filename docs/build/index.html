<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Homotopy Continuation For Tensor Decomposition · HomotopyContinuationForTensorDecomposition</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="HomotopyContinuationForTensorDecomposition logo"/></a><div class="docs-package-name"><span class="docs-autofit">HomotopyContinuationForTensorDecomposition</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Homotopy Continuation For Tensor Decomposition</a><ul class="internal"><li><a class="tocitem" href="#Getting-Started-1"><span>Getting Started</span></a></li><li><a class="tocitem" href="#Benchmarking-1"><span>Benchmarking</span></a></li><li><a class="tocitem" href="#CPD-methods-1"><span>CPD methods</span></a></li><li><a class="tocitem" href="#Benchmarks-1"><span>Benchmarks</span></a></li><li><a class="tocitem" href="#Helper-functions-1"><span>Helper functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Homotopy Continuation For Tensor Decomposition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Homotopy Continuation For Tensor Decomposition</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/835712/tensor-cp-continuation/blob/master/5_Package/HomotopyContinuationForTensorDecomposition/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Homotopy-Continuation-For-Tensor-Decomposition-1"><a class="docs-heading-anchor" href="#Homotopy-Continuation-For-Tensor-Decomposition-1">Homotopy Continuation For Tensor Decomposition</a><a class="docs-heading-anchor-permalink" href="#Homotopy-Continuation-For-Tensor-Decomposition-1" title="Permalink"></a></h1><p>This is a short and rudimentary user guide for Homotopy Continuation For Tensor Decomposition. This package comes with my master&#39;s thesis and detailed motivations for the algorithms available in this package can be found in the thesis text.</p><h2 id="Getting-Started-1"><a class="docs-heading-anchor" href="#Getting-Started-1">Getting Started</a><a class="docs-heading-anchor-permalink" href="#Getting-Started-1" title="Permalink"></a></h2><h3 id="Installing-the-package-1"><a class="docs-heading-anchor" href="#Installing-the-package-1">Installing the package</a><a class="docs-heading-anchor-permalink" href="#Installing-the-package-1" title="Permalink"></a></h3><p>Since this is not an official package, it has to be installed manually.</p><p>First, load all the dependencies via Julia&#39;s package manager.</p><pre><code class="language-julia">using Pkg

Pkg.activate(&quot;path/to/HomotopyContinuationForTensorDecomposition&quot;)

Pkg.instantiate()</code></pre><p>Secondly, we should install HomotopyContinuationForTensorDecomposition. There are two ways to do this.</p><ul><li>Add <code>HomotopyContinuationForTensorDecomposition.jl</code> to Julia&#39;s <code>LOAD_PATH</code>.</li></ul><pre><code class="language-julia">push!(LOAD_PATH,&quot;path/to/src/HomotopyContinuationForTensorDecomposition.jl&quot;)

using HomotopyContinuationForTensorDecomposition
</code></pre><ul><li>Use <code>include()</code>.</li></ul><pre><code class="language-julia">include(&quot;path/to/src/HomotopyContinuationForTensorDecomposition.jl&quot;)

using .HomotopyContinuationForTensorDecomposition
</code></pre><h3 id="A-first-example-1"><a class="docs-heading-anchor" href="#A-first-example-1">A first example</a><a class="docs-heading-anchor-permalink" href="#A-first-example-1" title="Permalink"></a></h3><p>The example below shows how to interact with the implemented algorithms.</p><pre><code class="language-julia">using LinearAlgebra: norm

dims = (43, 8, 7); # dimensions of the tensor
r = 5; # tensor rank

X, Y, Z, T = cpd_gen(dims, r); # generate a random tensor

Xcalc, Ycalc, Zcalc = cpd(T, dims, r);

Tcalc = cpd_gen(Xcalc, Ycalc, Zcalc);

norm(Tcalc - T)/norm(T) # backward relative error</code></pre><pre><code class="language-none">3.0987487849154017e-15</code></pre><p>The implemented algorithms only work for third order tensors with dimensions (n₁, n₂, n₃) for which it holds that r &lt; min(n₁, n₂n₃) and n₁ ≧ n₂ ≧ n₃. The implemented methods are:</p><ol><li><code>kl_cpd</code> (cpd via the method described by Kuo, Lee [1]);</li><li><code>kld_fd_cpd</code> (cpd via the dual problem by reducing the size of the square system);</li><li><code>kld_pr_cpd</code> (cpd via the dual problem by a parameter homotopy);</li><li><code>kl_lr_cpd</code> (Kuo and Lee&#39;s method optimised for low ranks);</li><li><code>cpd</code> (wrapper which selects the optimal method from those above).</li></ol><p>[1] <em>Y.-C. Kuo and T.-L. Lee. Computing the unique candecomp/parafac decomposition of unbalanced tensors by homotopie method. Linear Algebra and its applications, 556:238–264, 2018.</em></p><h2 id="Benchmarking-1"><a class="docs-heading-anchor" href="#Benchmarking-1">Benchmarking</a><a class="docs-heading-anchor-permalink" href="#Benchmarking-1" title="Permalink"></a></h2><p>The file <code>benchmarks/Benchmark.jl</code> contains a small module to test the performance of the different algorithms. Additionally, an interface with <code>Tensorlab2016</code>[2] is provided via the <code>MATLAB</code> package. The following four steps explain how to run some tests.</p><ul><li>Set Julia&#39;s working directory to <code>../benchmarks</code>.</li></ul><pre><code class="language-julia">cd(&quot;path/to/HomotopyContinuationForTensorDecomposition/benchmarks&quot;)</code></pre><ul><li><p>Put a copy of Tensorlab2016 in <code>../benchmarks</code>.</p></li><li><p>Load the <code>Benchmarks</code> module.</p></li></ul><pre><code class="language-julia">include(&quot;Benchmark.jl&quot;)

using .Benchmarks</code></pre><ul><li>Call the function <code>run_benchmark()</code>.</li></ul><pre><code class="language-julia">run_benchmark().</code></pre><p>This starts a command line interface through which it is possible to provide all the experiment settings. Should the options provided there be insufficient, experiments can be created manually and passed as an argument to <code>run_benchmark</code>.</p><pre><code class="language-julia">
?Benchmarkinstance # show documentation for the benchmarkinstance

# every experiment is represented by a Benchmarkinstance
bmis = Benchmarkinstance[]

dims = (43, 8, 7);
r = 15;
model = 1;
s = 2.0;
c = 1.0;

push!(bmis, Benchmarkinstance(dims, r; model=model, s=s, c=c));

run_benchmark(bmis); # run the experiments in `bmis`
# ...
</code></pre><p>The experiment results will be saved in a <code>.csv</code> file in the folder <code>../data</code>. Before and after the experiment <code>run_benchmark()</code> prints the exact file name. Additionally, the measurements are printed during the experiment.</p><p>[2] <em>Vervliet N., Debals O., Sorber L., Van Barel M. and De Lathauwer L. Tensorlab 3.0, Available online, Mar. 2016. URL:</em> https://www.tensorlab.net/</p><h2 id="CPD-methods-1"><a class="docs-heading-anchor" href="#CPD-methods-1">CPD methods</a><a class="docs-heading-anchor-permalink" href="#CPD-methods-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuationForTensorDecomposition.cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Tuple{Int64,Int64,Int64},Int64}} where d_type" href="#HomotopyContinuationForTensorDecomposition.cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Tuple{Int64,Int64,Int64},Int64}} where d_type"><code>HomotopyContinuationForTensorDecomposition.cpd</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>cpd(T, dims, r)</code></strong></p><p>Chooses and calls the most efficiënt algorithm from</p><ol><li><code>kl_cpd</code></li><li><code>kld_fd_cpd</code></li><li><code>kld_pr_cpd</code></li><li><code>kl_lr_cpd</code></li></ol><p>by taking into acount the dimensions and the rank.</p><ul><li>if r &lt; n₂ and r &lt; n₃: <code>kl_lr_cpd</code></li><li>if r &lt; n₂ or r &lt; n₃: <code>kld_fd_cpd</code></li><li>if r &lt;= n₂+n₃-2: <code>kld_pr_cpd</code></li><li>if r &lt; n₁: <code>kl_cpd</code></li></ul><p>If none of the above conditions are met, <code>cpd</code> throws an assertion error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/HomotopyContinuationForTensorDecomposition.jl#L89-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KuoLee.kl_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type" href="#KuoLee.kl_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type"><code>KuoLee.kl_cpd</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>kl_cpd</code></strong></p><p>Calculate the cpd of an order 3 tensor via the method described in Kuo, Lee.</p><p><em>Y.-C. Kuo and T.-L. Lee. Computing the unique candecomp/parafac decomposition of unbalanced tensors by homotopie method. Linear Algebra and its applications, 556:238–264, 2018.</em></p><p><strong>Inputs</strong></p><ul><li><code>T</code>: flattened real or complex tensor, type <code>Array{d_type, 2}</code></li><li><code>r</code>: rank of the tensor, type <code>Int64</code></li><li><code>dims</code>: tuple of the dimensions, first dimension should be larger than r, type <code>Tuple{Int64, Int64, Int64}</code>.</li></ul><p><strong>Outputs</strong></p><p>The method outputs the calculated factor matrices</p><div>\[    T \approx (Z_{\text{calc}} \odot Y_{\text{calc}})X_{\text{calc}}^H\]</div><ul><li><code>Xcalc</code></li><li><code>Ycalc</code></li><li><code>Zcalc</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">dims = (43, 8, 7);
r = 17;
X, Y, Z, T = cpd_gen(dims, r);

Xcalc, Ycalc, Zcalc = kl_cpd(T, r, dims);

T̃ = cpd_gen(Xcalc, Ycalc, Zcalc);
ϵ = norm(T-T̃)/norm(T);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/KuoLee.jl#L33-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KuoLee.kl_lr_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type" href="#KuoLee.kl_lr_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type"><code>KuoLee.kl_lr_cpd</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>kl_lr_cpd</code></strong></p><p>Calculate the cpd of an order 3 unbalanced flattened tensor via the method described in Kuo, Lee.</p><p><em>Y.-C. Kuo and T.-L. Lee. Computing the unique candecomp/parafac decomposition of unbalanced tensors by homotopie method. Linear Algebra and its applications, 556:238–264, 2018.</em></p><p>This method is optimised towards lower ranks: r &lt; n₂ and r &lt; n₃. The flattened tensor has the following decomposition:</p><div>\[    T = (Z \odot Y)X^H = EF^H.\]</div><p>As described in the thesis, this method exploits the information that the linear subspaces 𝐘 and 𝐙 are r dimensional and known. Therefor we search a basis Y for 𝐘 and a basis Z for 𝐙 s.t. Z ⊙ Y is a basis for E.</p><p><strong>Inputs</strong></p><ul><li><code>T</code>: flattened real or complex tensor, type <code>Array{d_type, 2}</code></li><li><code>r</code>: rank of the tensor, type <code>Int64</code></li><li><code>dims</code>: tuple of the dimensions, first dimension should be larger than r, type <code>Tuple{Int64, Int64, Int64}</code>.</li></ul><p><strong>Outputs</strong></p><p>The method outputs the calculated factor matrices</p><div>\[    T \approx (Z_{\text{calc}} \odot Y_{\text{calc}})X_{\text{calc}}^H\]</div><ul><li><code>Xcalc</code></li><li><code>Ycalc</code></li><li><code>Zcalc</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/KuoLee.jl#L174-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dual.kld_fd_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type" href="#Dual.kld_fd_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type"><code>Dual.kld_fd_cpd</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>kld_fd_cpd</code></strong></p><p>Calculate the cpd of a flattened order 3 tensor via the dual problem. The algoritm numerically reduces the size of the square system used for homotopy continuation by setting some variables to a random value. This method solves the dual problem by calling <code>dual_solve</code> and than translates the dual problem to the primal via <code>translate_dual_prim</code>. The documentation of these methods elaborates more on the techniques used.</p><p><strong>Inputs</strong></p><ul><li><code>T</code>: flattened real or complex tensor</li><li><code>r</code>: rank of the cpd</li><li><code>dims</code>: tuple of the dimensions, first dimension should be larger than r.</li></ul><p><strong>Outputs</strong></p><p>The method outputs the calculated factor matrices</p><div>\[    T \approx (Z_{\text{calc}} \odot Y_{\text{calc}})X_{\text{calc}}^H\]</div><ul><li><code>Xcalc</code></li><li><code>Ycalc</code></li><li><code>Zcalc</code></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>maxit_basis</code>: (<code>Int64</code>) maximum number of iterations used in <code>solve_dual</code>.</li><li><code>maxit_ortho</code>: (<code>Int64</code>) maximum number of iterations used in <code>translate_dual_prim</code>.</li><li><code>verbose</code>: (<code>Bool</code>) give some information about the number of iterations / the type of problems solved.</li><li><code>strategy</code>: (<code>String</code>) tell <code>solve_dual</code> which methods it should use to grow the basis. See <code>solve_dual</code> for the possible values.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">dims = (43, 8, 7);
r = 6;
X, Y, Z, T = cpd_gen(dims, r);

Xcalc, Ycalc, Zcalc = kld_fd_cpd(T, r, dims);

T̃ = cpd_gen(Xcalc, Ycalc, Zcalc);
ϵ = norm(T-T̃)/norm(T);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/Dual.jl#L13-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dual.kld_pr_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type" href="#Dual.kld_pr_cpd-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64,Tuple{Int64,Int64,Int64}}} where d_type"><code>Dual.kld_pr_cpd</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>kld_pr_cpd</code></strong></p><p>Calculate the cpd of an order 3 unbalanced flattened tensor. This method uses a parameter homotopy to solve the dual problem. This function constructs an initial decomposition and then calls <code>kld_pr_cpd_refine</code>.</p><p><strong>Inputs</strong></p><ul><li><code>T₁</code>: flattened tensor</li><li><code>r</code>: rank of <code>T₁</code></li><li><code>dims</code>: tuple with dimensions <code>(n₁, n₂, n₃)</code> of the tensor  such that   <code>T₁</code> has dimensions n₂n₃×n₁</li></ul><p><strong>Outputs</strong></p><p>The method outputs the calculated factor matrices</p><div>\[    T \approx (Z_{\text{calc}} \odot Y_{\text{calc}})X_{\text{calc}}^H\]</div><ul><li><code>Xcalc</code></li><li><code>Ycalc</code></li><li><code>Zcalc</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/Dual.jl#L337-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Dual.kld_pr_cpd_refine-NTuple{6,Any}" href="#Dual.kld_pr_cpd_refine-NTuple{6,Any}"><code>Dual.kld_pr_cpd_refine</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>kld_pr_cpd_refine</code></strong></p><p>Calculate the cpd of an unbalanced flattened order 3 tensor via the dual problem.  The method solves the dual problem by paramter homotopy and requires an initial decomposition.     See <code>kl_pr_cpd</code>for a wrapper which also constructs the initial decomposition.</p><p><strong>Inputs</strong></p><ul><li><code>T₀</code>: start flattened tensor</li><li><code>T₁</code>: target flattened tensor</li><li><code>Y₀</code>: factor matrix of start tensor</li><li><code>Z₀</code>: factor matrix of start tensor</li><li><code>dims</code>:  dimensions <code>(n₁, n₂, n₃)</code> of start and target tensor.   <code>Y₀</code> should have dimensions n₂×r, <code>Z₀</code> should have dimensions n₃×r.</li><li><code>r</code>: rank of the tensor</li></ul><p><strong>Outputs</strong></p><p>The method outputs the calculated factor matrices</p><div>\[    T \approx (Z_{\text{calc}} \odot Y_{\text{calc}})X_{\text{calc}}^H\]</div><ul><li><code>Xcalc</code></li><li><code>Ycalc</code></li><li><code>Zcalc</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/Dual.jl#L190-L219">source</a></section></article><h2 id="Benchmarks-1"><a class="docs-heading-anchor" href="#Benchmarks-1">Benchmarks</a><a class="docs-heading-anchor-permalink" href="#Benchmarks-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Benchmarks.run_benchmark" href="#Benchmarks.run_benchmark"><code>Benchmarks.run_benchmark</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong><code>run_benchmark</code></strong></p><p>Script which will run experiments. The script prompts for user feedback after printing the settings to the shell. This allows the user to still throw an interrupt exception using ctrl-C.</p><p>The following variables have to be manually inserted in <code>Benchmarks.jl</code></p><ul><li><code>nb_warmup</code>: number of iterations before we take a measurement.</li><li><code>nb_samples</code>: number of measurements to take for each experiment (or benchmark_instance).</li><li><code>benchmark_set</code>: list of experiments (<code>benchmark_instance</code>) to perform.</li><li><code>kl</code>: (<code>Bool</code>) indicate if we run <code>kl_cpd</code>. This is mostly the most expensive method.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/benchmarks/Benchmarks.jl#L302-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Benchmarks.Benchmarkinstance" href="#Benchmarks.Benchmarkinstance"><code>Benchmarks.Benchmarkinstance</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong><code>Benchmarkinstance</code></strong></p><p>Struct which represents an experiment to perform.</p><p><strong>Contains</strong></p><ul><li><code>n₁</code>: first dimension of tensor.</li><li><code>n₂</code>: second dimension of tensor.</li><li><code>n₃</code>: third dimension of tensor.</li><li><code>r</code>: rank of the tensor.</li><li><code>η</code>: parameter to controll noise. The noise is applied to the tensor to approximate the empirical condition number.</li><li><code>model</code>: the model used to construct the tensor. The models are described in [3]</li><li><code>s</code>: parameter used in model 1 and model 2</li><li><code>c</code>: parameter used in model 1</li><li><code>sample_fm</code>: can only be false if the tensor format is perfect. In that case a random tensor is generated directly. If true the tensor is generated form random factor matrices.</li></ul><p>[3] <em>Breiding and Vannieuwenhoven, A Riemannian trust region method for the canonical tensor rank approximation problem</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/benchmarks/Benchmarks.jl#L38-L57">source</a></section></article><h2 id="Helper-functions-1"><a class="docs-heading-anchor" href="#Helper-functions-1">Helper functions</a><a class="docs-heading-anchor-permalink" href="#Helper-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DualUtils.dual_solve-Union{Tuple{d_type}, Tuple{Array{d_type,2},Tuple{Int64,Int64,Int64},Int64}} where d_type" href="#DualUtils.dual_solve-Union{Tuple{d_type}, Tuple{Array{d_type,2},Tuple{Int64,Int64,Int64},Int64}} where d_type"><code>DualUtils.dual_solve</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>dual_solve</code></strong></p><p>Calculates a rank-one basis for Null(E&#39;) by intersecting the positive dimensional variety with hyperplanes. The dimensions of E are n₂n₃ × r. Requires that r &lt; n₂ + n₃ - 2.</p><p>All solutions (𝐮ⱼ, 𝐯ⱼ) satisfy</p><div>\[    (\mathbf{u}_j \odot \mathbf{v}_j)^H\mathbf{e}_i = 0, \quad \forall i=1,\dots, r,\quad \forall j=1,\dots, n_2n_3-r.\]</div><p>This method is a wrapper for constructing random systems, solving them and afterwards parsing and checking the solutions. Three different solvers are used:</p><ol><li><code>Linpolysolve()</code>: if r &lt; n₂ or r &lt; n₃ it is possible to contruct linear systems in r variables. If this is done depends on the given strategy.</li><li>Full degree solver: calculates all solutions of a nonlinear system using <code>HomotopyContinuation</code>.</li><li><code>dual_paramsolve</code>: calculates a set of solutions using, then tracks these solutions while the parameters of the system (those which define the hyperplanes) are changed.</li></ol><p>Using the default strategy &#39;x<em>last</em>xy&#39; (old naming convention) the method will start by dehomogenizing the system such that it is linear in 𝐯 if r &lt; n₂. When no new independent solutions are found, it will use r variables in 𝐯 and one in 𝐮. In the case that r &gt; n₂, all variables in 𝐯 and r-n₂ variables in 𝐳 are used.</p><p><strong>Inputs</strong></p><ul><li><code>E</code> basis for the space 𝐄 to which we seek orthogonal rank-one vectors.</li><li><code>dims</code> dimensions of the tensor.</li><li><code>r</code> rank of the tensor.</li></ul><p><strong>Outputs</strong></p><ul><li><code>success</code>: integer flag which equals 1 if all went well.</li><li><code>N</code>: the rank-one basis for 𝐍 = Nul(𝐄)</li><li><code>UV</code>: container with the vectors 𝐮 and 𝐯 such that 𝐮ⱼ ⊙ 𝐯ⱼ = 𝐧ⱼ. The vector 𝐮ⱼ can be accessed as <code>UV[j][2]</code> and the vector 𝐯ⱼ as <code>UV[j][1]</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>verbose</code>: print some info to the command line</li><li><code>strategy</code>: indicate a strategy to numerically eliminate variables.</li></ul><p><strong>Strategies</strong></p><p>The strategy can be set via the keyword argument <code>strategy</code>. Possible values are</p><p>!!! note The strategy names come from an old naming convention.</p><ul><li><code>&quot;x_last_xy&quot;</code>: if r &lt; n₂ eliminate all variables in 𝐮 such that the dual problem is linear in 𝐯. Once this doesn&#39;t result in new solutions or r &gt;= n₂, solve non-linear systems with one variable in 𝐯 and r variables in 𝐮 with the full degree solver.</li><li><code>&quot;y_last_yx&quot;</code>: if r &lt; n₃ eliminate all variables in 𝐯 such that the dual problem is linear in 𝐮. Once this doesn&#39;t result in new solutions or r &gt;= n₃, solve non-linear systems with one variable in 𝐮 and r variables in 𝐯 with the full degree solver.</li><li><code>&quot;optimal&quot;</code>: choose automatically between <code>&quot;x_last_xy&quot;</code> and <code>&quot;y_last_yx&quot;</code> such that linear systems are used when r &lt; n₂ or r &lt; n₃.</li><li><code>&quot;x_last_xypar&quot;</code>: (not properly tested) similar to <code>&quot;x_last_xy&quot;</code> but <code>dual_paramsolve</code> is used to solve the nonlinear systems.</li><li><code>&quot;y_last_yxpar&quot;</code>: (not properly tested) similar to <code>&quot;y_last_yx&quot;</code> but <code>dual_paramsolve</code> is used to solve the nonlinear systems.</li></ul><p><strong>Possible improvements:</strong></p><ol><li>Optimise memory allocation. Most memory is still allocated &#39;on the fly&#39;.</li><li>Uniform naming conventions in all helper functions.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/DualUtils.jl#L39-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DualUtils.rankfact_nullspace-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64}} where d_type" href="#DualUtils.rankfact_nullspace-Union{Tuple{d_type}, Tuple{Array{d_type,2},Int64}} where d_type"><code>DualUtils.rankfact_nullspace</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>rankfact_nullspace</code></strong></p><p>Calculate the full rank factorisation of T s.t. T = EF&#39; and N = null(E&#39;).</p><p><strong>Inputs</strong></p><ul><li><code>T</code>: matrix to factorize</li><li><code>r</code>: rank of t</li></ul><p><strong>Outputs</strong></p><ul><li><code>E</code>: matrix such that T = EF&#39;</li><li><code>F</code>: matrix such that T = EF&#39;</li><li><code>N</code>: matrix such that N&#39;E = 0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/DualUtils.jl#L9-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DualUtils.translate_dual_prim-NTuple{4,Any}" href="#DualUtils.translate_dual_prim-NTuple{4,Any}"><code>DualUtils.translate_dual_prim</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>translate<em>dual</em>prim</strong></p><p>Calculate a rank-one basis Z ⊙ Y orthogonal to U ⊙ V. The dimensions are</p><ul><li><code>U</code>: n₃ × n₂n₃-r;</li><li><code>V</code>: n₂ × n₂n₃-r;</li><li><code>Z</code>: n₃ × r;</li><li><code>Y</code>: n₂ × r.</li></ul><p>This solutions (𝐲ᵢ, 𝐳ᵢ) satisfy</p><div>\[    (\mathbf{u}_j \odot \mathbf{v}_j)^H(\mathbf{z}_i \odot \mathbf{y}_i) = 0, \quad \forall i=1,\dots, r,\quad \forall j=1,\dots, n_2n_3-r.\]</div><p>Moreover the unless <code>soft</code> is activated the method asserts that the returned solutions are zero-dimensional.</p><p><strong>Inputs</strong></p><ul><li><code>V</code>: see above.</li><li><code>U</code>: see above.</li><li><code>dims</code>: see above.</li><li><code>r</code>: see above.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>verbose</code>: (<code>true</code>/<code>false</code>) provide some output on the number of iterations.</li><li><code>maxit</code>: (int) maximum number of iterations.</li><li><code>sigma_threshold</code>: (float) decides when a new vector is considered to be part N. If σ[end]/σ[1] &lt; sigma_threshold the solution is rejected due to linear dependency.</li><li><code>soft</code>: (<code>true</code>/<code>false</code>) silences assertions for zero-dimensional solution components. Thus, activating <code>soft</code> will not interrupt the software if a positive dimensional solution component is encountered.</li></ul><p><strong>Outputs</strong></p><ul><li><code>success</code>: flag which equals the interger one if the method succeeded.</li><li><code>YZ</code>: container for 𝐲ᵢ and 𝐳ᵢ which can be accessed as <code>YZ[i][1]</code> and <code>YZ[i][2]</code>.</li></ul><p><strong>Possible improvements</strong></p><ul><li>reduce the number of calls to <code>nullspace</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/DualUtils.jl#L240-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DualUtils.combis-Tuple{Any,Any,Any}" href="#DualUtils.combis-Tuple{Any,Any,Any}"><code>DualUtils.combis</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>combis</strong></p><p>Experimental function to generate some combinatorics. Creates different combinations of <code>select_nb</code> elements out of <code>select_list</code>. The method stops if it can find no new samples or if the number of combinations reaches <code>nb_samples</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/DualUtils.jl#L1082-L1087">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DualUtils.dual_constructvars-NTuple{10,Any}" href="#DualUtils.dual_constructvars-NTuple{10,Any}"><code>DualUtils.dual_constructvars</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>dual_constructvars</strong></p><p>Helper function for the <code>dual_solve()</code> method. The function constructs two arrays of variables 𝐯 and 𝐮     which have a random set of elements set to a random value.</p><p>!!! note Internally this method uses a different naming convention.</p><p><strong>Inputs</strong></p><ul><li><code>n₂</code>: (int) dimension of 𝐯 (corresponding tensor has dimensions n₁×n₂×n₃).</li><li><code>n₃</code>: (int) dimension of 𝐮.</li><li><code>r</code>: (int) rank of the corresponding tensor.</li><li><code>verbose</code>: print some information about the proceedings to stdout.</li><li><code>setuv</code>: (string) defines which variables should be set.</li><li><code>X_combos</code>: (old naming convention, <code>V_combos</code> would be more appropriate) list of different combinations of r numbers from the range 1:n₂.</li><li><code>Y_combos</code>: (old naming convention, <code>U_combos</code> would be more appropriate) list of different combinations of r numbers from the range 1:n₃:</li><li><code>Xcomb_index</code>: (old naming convention) tells the method which &#39;combo&#39; of <code>X_combos</code> should be used.</li><li><code>Ycomb_index</code>: (old naming convention) similar as above.</li><li><code>it</code>: global iteration counter. Used to only print a message during the first iteration if <code>verbose</code> equals <code>true</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>x</code>: (old naming convention, <code>𝐯</code> would be more appropriate) array consisting of <code>PolyVar</code> types and / or random values.</li><li><code>y</code>: (old naming convention, <code>𝐮</code> would be more appropriate) similar as above.</li><li><code>t</code>: if the polynomial system is solved with <code>dual_paramsolve</code>, then <code>t</code> represents the <code>PolyVar</code>s in <code>x</code> and <code>y</code> which would otherwise be set to a random value.</li><li><code>add_eqs</code>: if there are more than r variables (<code>PolyVar</code>), then <code>add_eqs</code> communicates this further.</li><li><code>rm_eqs</code>: depreciated</li><li><code>setuv</code>: (string) communicates which variables are set.</li><li><code>vars</code>: array of all variables in the polynomial system (only &#39;true&#39; variables, so no parameters such as <code>t</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/DualUtils.jl#L439-L473">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DualUtils.dual_deparsevars-NTuple{13,Any}" href="#DualUtils.dual_deparsevars-NTuple{13,Any}"><code>DualUtils.dual_deparsevars</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>dual_deparsevars</strong></p><p>Put the solutions 𝛇 of the polynomial system at the right place in 𝐮 and 𝐯. Can be interpreted as the inverse function of <code>dual_constructvars</code>.</p><p>!!! note Still uses an old naming convention internally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/DualUtils.jl#L614-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DualUtils.dual_filtsols-NTuple{8,Any}" href="#DualUtils.dual_filtsols-NTuple{8,Any}"><code>DualUtils.dual_filtsols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"># dual_filtsols</code></pre><p>Filter all solutions in 𝐧_list such that</p><ol><li>their residual is low enough</li><li>they are not trivial</li><li>if added to the basis N, the vectors are independent enough.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/DualUtils.jl#L688-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DualUtils.dual_paramsolve-NTuple{9,Any}" href="#DualUtils.dual_paramsolve-NTuple{9,Any}"><code>DualUtils.dual_paramsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>dual_paramsolve</code></strong></p><p>The polynomial system is parametrised in t and u. This method first calculates a solution set for a random t<em>0 and u</em>0 after which it tracks those solutions to     random t<em>1 and u</em>1, then it tracks those to t<em>2 and u</em>2 and so on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/DualUtils.jl#L870-L876">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DualUtils.dual_solvepolysys-NTuple{13,Any}" href="#DualUtils.dual_solvepolysys-NTuple{13,Any}"><code>DualUtils.dual_solvepolysys</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>dual_solvepolysys</code></strong></p><p>Wrapper which based on given settings selects the right solver. It can call four different methods</p><ul><li><code>dual_paramsolve</code>: track a set of solutions to different locations in parameter space.</li><li><code>HomotopyContinuation.solve()</code>: full degree homotopy.</li><li><code>HomotopyContinuation.solve(…, variable_groups= …)</code>: full degree homotopy with m-homogeneous system.</li><li><code>linpolysolve</code>: solves a linear polynomial system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/DualUtils.jl#L998-L1008">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DualUtils.dual_track_single-Union{Tuple{d_type}, Tuple{Any,Array{d_type,2},Array{d_type,2},Any,Any}} where d_type" href="#DualUtils.dual_track_single-Union{Tuple{d_type}, Tuple{Any,Array{d_type,2},Array{d_type,2},Any,Any}} where d_type"><code>DualUtils.dual_track_single</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"># dual_track_single</code></pre><p>Track all solutions of the dual start problem to the target problem:</p><ul><li>start condition: U₀ ⊙ V₀ ⟂ E₀,</li><li>target condition: U₁ ⊙ V₁ ⟂ E₁.</li></ul><p><strong>Inputs</strong></p><ul><li><code>UV₀</code>: container for the start solutions.</li><li><code>E₀</code>: as explained above.</li><li><code>E₁</code>: as explained above.</li><li><code>dims</code>: (n₁, n₂, n₃) dimensions of the tensor. E₀ and E₁ have dimension   n₂n₃×r.</li><li><code>r</code>: rank of the tensor.</li></ul><p><strong>Outputs</strong></p><ul><li><code>success</code>: flag</li><li><code>UV₁</code>: container for target solutions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/DualUtils.jl#L1249-L1271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DualUtils.linpolysolve-Tuple{Any,Any}" href="#DualUtils.linpolysolve-Tuple{Any,Any}"><code>DualUtils.linpolysolve</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>linpolysolve</strong></p><p>Solves a system of degree one polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/DualUtils.jl#L1047-L1051">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KuoLeeUtils.constrpoly-Union{Tuple{d_type}, Tuple{Array{d_type,2},Tuple{Int64,Int64,Int64},Int64,Tuple{Array{v_type,1},Array{v_type,1}} where v_type}} where d_type" href="#KuoLeeUtils.constrpoly-Union{Tuple{d_type}, Tuple{Array{d_type,2},Tuple{Int64,Int64,Int64},Int64,Tuple{Array{v_type,1},Array{v_type,1}} where v_type}} where d_type"><code>KuoLeeUtils.constrpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>constrpoly</strong></p><p>Construct the polynomial system for the algorithm <code>kl_cpd</code>.</p><p><strong>Inputs</strong></p><ul><li><code>N</code>: space to which orthogonal rank-one vectors are sought</li><li><code>dims</code>: tensor dimensions</li><li><code>vars</code>: polynomial variables</li></ul><p><strong>Outputs</strong></p><ul><li><code>𝐩</code>: array of polynomial equations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/KuoLeeUtils.jl#L67-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KuoLeeUtils.filtsols-Union{Tuple{d_type}, Tuple{Array{Array{d_type,1},1},Array{d_type,2},Tuple{Int64,Int64,Int64},Int64}} where d_type" href="#KuoLeeUtils.filtsols-Union{Tuple{d_type}, Tuple{Array{Array{d_type,1},1},Array{d_type,2},Tuple{Int64,Int64,Int64},Int64}} where d_type"><code>KuoLeeUtils.filtsols</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>filtsols</strong></p><p>Filter solutions which are orthogonal to every vector in N.</p><p><strong>Inputs</strong></p><ul><li>𝛇: array of solution vectors</li><li>N: basis of space to which orthogonal vectors are sought</li><li>dims: dimensions of the tensor</li><li>r: rank of the tensor</li></ul><p><strong>Outputs</strong></p><ul><li>Y_filt: array of vectors 𝐲ᵢ (1≦i≦r) of length r such that residual of (𝐳ᵢ ⊙ 𝐲ᵢ)ᴴ𝐧ⱼ is smallest.</li><li>Z_filt: array of vectors 𝐳ᵢ (1≦i≦r) of length r such that residual of (𝐳ᵢ ⊙ 𝐲ᵢ)ᴴ𝐧ⱼ is smallest.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/KuoLeeUtils.jl#L182-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KuoLeeUtils.normbalance-Tuple{Array{#s17,2} where #s17&lt;:Number,Array{#s18,2} where #s18&lt;:Number,Array{#s19,2} where #s19&lt;:Number}" href="#KuoLeeUtils.normbalance-Tuple{Array{#s17,2} where #s17&lt;:Number,Array{#s18,2} where #s18&lt;:Number,Array{#s19,2} where #s19&lt;:Number}"><code>KuoLeeUtils.normbalance</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Normbalance</strong></p><p>Distribute the norm equally over all factor vectors. Put all angle in X.</p><p><strong>Inputs</strong></p><ul><li>X</li><li>Y</li><li>Z</li></ul><p><strong>Outputs</strong></p><ul><li>X: factor matrix X s.t. ||𝐱ᵢ|| = ||𝐲ᵢ|| = ||𝐳ᵢ|| ∠xᵢ₁ = 0. ∀ i,</li><li>Y: factor matrix Y s.t. ||𝐱ᵢ|| = ||𝐲ᵢ|| = ||𝐳ᵢ|| ∠yᵢ₁ = 0. ∀ i,</li><li>Z: factor matrix Z s.t. ||𝐱ᵢ|| = ||𝐲ᵢ|| = ||𝐳ᵢ|| ∀ i</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/KuoLeeUtils.jl#L274-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KuoLeeUtils.rankfact-Tuple{Array{#s13,2} where #s13&lt;:Number,Int64}" href="#KuoLeeUtils.rankfact-Tuple{Array{#s13,2} where #s13&lt;:Number,Int64}"><code>KuoLeeUtils.rankfact</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Rankfact</strong></p><p>Factorize a matrix in rank one matrices via the singular value decomposition.</p><div>\[    T = EF^T, \quad E \in \mathbb{F}^{n_2n_3 \times r}, \quad F\in \mathbb{F}^{n_1\times R}
\]</div><div>\[    T = U \Sigma V^T, \quad E = U, \quad F^T = \Sigma V^T.\]</div><p><strong>Inputs</strong></p><ul><li>T: two-dimensonal array to be factorized</li><li>r: number of rank one terms</li></ul><p><strong>Output</strong></p><ul><li>E: E and F are the factor matrices of the factorization</li><li>F: E anf F are the factor matrices of the factorization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/KuoLeeUtils.jl#L28-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Utils.condtdp-NTuple{5,Any}" href="#Utils.condtdp-NTuple{5,Any}"><code>Utils.condtdp</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>condtdp</code></strong></p><p>Calculate the condition number of the tensor decomposition problem based on Terracini&#39;s matrix.</p><p><strong>Inputs</strong></p><ul><li><code>X</code></li><li><code>Y</code></li><li><code>Z</code></li><li><code>dims</code></li><li><code>R</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/Utils.jl#L122-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Utils.cpd_gen-Tuple{Tuple{Int64,Int64,Int64},Int64}" href="#Utils.cpd_gen-Tuple{Tuple{Int64,Int64,Int64},Int64}"><code>Utils.cpd_gen</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>cpd_gen(dims, r)</code></strong></p><p>Generate a flattened tensor with dimensions n₂n₃×n₁ of rank r. The tensor is generated from random factor matrices as</p><div>\[
    T = (Z \odot Y)X^H.
\]</div><p><strong>Inputs</strong></p><ul><li><code>dims</code>: tuple with the dimensions <code>(n₁, n₂, n₃)</code>.</li><li><code>r</code>: the desired tensor rank</li></ul><p><strong>Output</strong></p><ul><li><code>X</code>: factor matrix of dimension n₁×r</li><li><code>Y</code>: factor matrix of dimension n₂×r</li><li><code>Z</code>: factor matrix of dimension n₃×r</li><li><code>T</code>: flattened tensor n₂n₃×n₁</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/Utils.jl#L8-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Utils.cpd_gen-Union{Tuple{d_type}, Tuple{Array{d_type,2},Array{d_type,2},Array{d_type,2}}} where d_type" href="#Utils.cpd_gen-Union{Tuple{d_type}, Tuple{Array{d_type,2},Array{d_type,2},Array{d_type,2}}} where d_type"><code>Utils.cpd_gen</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong><code>cpd_gen(X, Y, Z)</code></strong></p><p>Generate a flattened tensor from the given factor matrices such that</p><div>\[
    T = (Z \odot Y)X^H.
\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/Utils.jl#L46-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Utils.signnorm-Tuple{Array{#s18,N} where N where #s18&lt;:Number}" href="#Utils.signnorm-Tuple{Array{#s18,N} where N where #s18&lt;:Number}"><code>Utils.signnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>signnorm</strong></p><p>Rescale matrix columns such that the first row has positive sign. In the case of complex entries, the elements on the first row have zero complex angle.</p><p><strong>Examples</strong></p><pre><code class="language-none">&gt;&gt; A
&gt;&gt; 2×2 Array{Complex{Float64},2}:
    1.30736-1.34255im    0.183123-0.504201im
    -0.00153446+0.0305201im  0.222609-0.0412371im
&gt;&gt; signnorm(A)
&gt;&gt; 2×2 Array{Complex{Float64},2}:
    1.87393+1.5908e-16im  0.536426-2.60882e-17im
    -0.0229362+0.0201932im   0.114753+0.195159im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/835712/tensor-cp-continuation/blob/5a74c5851ba9a6529cdf65c647ffd0d5618fee7b/5_Package/HomotopyContinuationForTensorDecomposition/src/Utils.jl#L99-L116">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 5 June 2020 10:32">Friday 5 June 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
